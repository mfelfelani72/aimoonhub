"use strict";(self.webpackChunkbuiler=self.webpackChunkbuiler||[]).push([[6071],{66071:(t,s,i)=>{i.d(s,{n:()=>C});var n=i(56257),e=i(65744),o=i(20538),a=i(1207),r=i(8104),l=i(19293),h=i(63998),u=i(92901),c=i(71912),g=i(38448),p=i(55120),d=i(54106),m=i(75338),v=i(94805),P=i(84364),f=i(83953),E=i(50029),D=i(92275),A=i(12301);const x=new WeakMap;class C{constructor(t){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=(0,d.ge)(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=t}start(t,{snapToCursor:s=!1,distanceThreshold:i}={}){const{presenceContext:e}=this.visualElement;if(e&&!1===e.isPresent)return;const{dragSnapToOrigin:r}=this.getProps();this.panSession=new D.Q(t,{onSessionStart:t=>{const{dragSnapToOrigin:i}=this.getProps();i?this.pauseAnimation():this.stopAnimation(),s&&this.snapToCursor((0,c.e)(t).point)},onStart:(t,s)=>{const{drag:i,dragPropagation:e,onDragStart:r}=this.getProps();if(i&&!e&&(this.openDragLock&&this.openDragLock(),this.openDragLock=(0,n.W)(i),!this.openDragLock))return;this.latestPointerEvent=t,this.latestPanInfo=s,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),(0,m.X)(t=>{let s=this.getAxisMotionValue(t).get()||0;if(o.KN.test(s)){const{projection:i}=this.visualElement;if(i&&i.layout){const n=i.layout.layoutBox[t];n&&(s=(0,p.CQ)(n)*(parseFloat(s)/100))}}this.originPoint[t]=s}),r&&a.Gt.postRender(()=>r(t,s)),(0,E.g)(this.visualElement,"transform");const{animationState:l}=this.visualElement;l&&l.setActive("whileDrag",!0)},onMove:(t,s)=>{this.latestPointerEvent=t,this.latestPanInfo=s;const{dragPropagation:i,dragDirectionLock:n,onDirectionLock:e,onDrag:o}=this.getProps();if(!i&&!this.openDragLock)return;const{offset:a}=s;if(n&&null===this.currentDirection)return this.currentDirection=function(t,s=10){let i=null;return Math.abs(t.y)>s?i="y":Math.abs(t.x)>s&&(i="x"),i}(a),void(null!==this.currentDirection&&e&&e(this.currentDirection));this.updateAxis("x",s.point,a),this.updateAxis("y",s.point,a),this.visualElement.render(),o&&o(t,s)},onSessionEnd:(t,s)=>{this.latestPointerEvent=t,this.latestPanInfo=s,this.stop(t,s),this.latestPointerEvent=null,this.latestPanInfo=null},resumeAnimation:()=>(0,m.X)(t=>"paused"===this.getAnimationState(t)&&this.getAxisMotionValue(t).animation?.play())},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:r,distanceThreshold:i,contextWindow:(0,P.s)(this.visualElement)})}stop(t,s){const i=t||this.latestPointerEvent,n=s||this.latestPanInfo,e=this.isDragging;if(this.cancel(),!e||!n||!i)return;const{velocity:o}=n;this.startAnimation(o);const{onDragEnd:r}=this.getProps();r&&a.Gt.postRender(()=>r(i,n))}cancel(){this.isDragging=!1;const{projection:t,animationState:s}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:i}=this.getProps();!i&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),s&&s.setActive("whileDrag",!1)}updateAxis(t,s,i){const{drag:n}=this.getProps();if(!i||!y(t,n,this.currentDirection))return;const e=this.getAxisMotionValue(t);let o=this.originPoint[t]+i[t];this.constraints&&this.constraints[t]&&(o=(0,A.Zq)(o,this.constraints[t],this.elastic[t])),e.set(o)}resolveConstraints(){const{dragConstraints:t,dragElastic:s}=this.getProps(),i=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,n=this.constraints;t&&(0,f.X)(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!t||!i)&&(0,A._c)(i.layoutBox,t),this.elastic=(0,A.my)(s),n!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&(0,m.X)(t=>{!1!==this.constraints&&this.getAxisMotionValue(t)&&(this.constraints[t]=(0,A.QX)(i.layoutBox[t],this.constraints[t]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:s}=this.getProps();if(!t||!(0,f.X)(t))return!1;const i=t.current;(0,r.V)(null!==i,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.","drag-constraints-ref");const{projection:n}=this.visualElement;if(!n||!n.layout)return!1;const e=(0,v.L)(i,n.root,this.visualElement.getTransformPagePoint());let o=(0,A.iT)(n.layout.layoutBox,e);if(s){const t=s((0,g.pA)(o));this.hasMutatedConstraints=!!t,t&&(o=(0,g.FY)(t))}return o}startAnimation(t){const{drag:s,dragMomentum:i,dragElastic:n,dragTransition:e,dragSnapToOrigin:o,onDragTransitionEnd:a}=this.getProps(),r=this.constraints||{},l=(0,m.X)(a=>{if(!y(a,s,this.currentDirection))return;let l=r&&r[a]||{};o&&(l={min:0,max:0});const h=n?200:1e6,u=n?40:1e7,c={type:"inertia",velocity:i?t[a]:0,bounceStiffness:h,bounceDamping:u,timeConstant:750,restDelta:1,restSpeed:10,...e,...l};return this.startAxisValueAnimation(a,c)});return Promise.all(l).then(a)}startAxisValueAnimation(t,s){const i=this.getAxisMotionValue(t);return(0,E.g)(this.visualElement,t),i.start((0,l.f)(t,i,0,s,this.visualElement,!1))}stopAnimation(){(0,m.X)(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){(0,m.X)(t=>this.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){return this.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){const s=`_drag${t.toUpperCase()}`,i=this.visualElement.getProps();return i[s]||this.visualElement.getValue(t,(i.initial?i.initial[t]:void 0)||0)}snapToCursor(t){(0,m.X)(s=>{const{drag:i}=this.getProps();if(!y(s,i,this.currentDirection))return;const{projection:n}=this.visualElement,o=this.getAxisMotionValue(s);if(n&&n.layout){const{min:i,max:a}=n.layout.layoutBox[s];o.set(t[s]-(0,e.k)(i,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:s}=this.getProps(),{projection:i}=this.visualElement;if(!(0,f.X)(s)||!i||!this.constraints)return;this.stopAnimation();const n={x:0,y:0};(0,m.X)(t=>{const s=this.getAxisMotionValue(t);if(s&&!1!==this.constraints){const i=s.get();n[t]=(0,A.Yu)({min:i,max:i},this.constraints[t])}});const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",i.root&&i.root.updateScroll(),i.updateLayout(),this.resolveConstraints(),(0,m.X)(s=>{if(!y(s,t,null))return;const i=this.getAxisMotionValue(s),{min:o,max:a}=this.constraints[s];i.set((0,e.k)(o,a,n[s]))})}addListeners(){if(!this.visualElement.current)return;x.set(this.visualElement,this);const t=this.visualElement.current,s=(0,u.h)(t,"pointerdown",t=>{const{drag:s,dragListener:i=!0}=this.getProps();s&&i&&this.start(t)}),i=()=>{const{dragConstraints:t}=this.getProps();(0,f.X)(t)&&t.current&&(this.constraints=this.resolveRefConstraints())},{projection:n}=this.visualElement,e=n.addEventListener("measure",i);n&&!n.layout&&(n.root&&n.root.updateScroll(),n.updateLayout()),a.Gt.read(i);const o=(0,h.k)(window,"resize",()=>this.scalePositionWithinConstraints()),r=n.addEventListener("didUpdate",({delta:t,hasLayoutChanged:s})=>{this.isDragging&&s&&((0,m.X)(s=>{const i=this.getAxisMotionValue(s);i&&(this.originPoint[s]+=t[s].translate,i.set(i.get()+t[s].translate))}),this.visualElement.render())});return()=>{o(),s(),e(),r&&r()}}getProps(){const t=this.visualElement.getProps(),{drag:s=!1,dragDirectionLock:i=!1,dragPropagation:n=!1,dragConstraints:e=!1,dragElastic:o=A.Ne,dragMomentum:a=!0}=t;return{...t,drag:s,dragDirectionLock:i,dragPropagation:n,dragConstraints:e,dragElastic:o,dragMomentum:a}}}function y(t,s,i){return!(!0!==s&&s!==t||null!==i&&i!==t)}}}]);